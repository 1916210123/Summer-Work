/*WENTI 与198打家劫舍类似
一个有名的按摩师会收到源源不断的预约请求,每个预约都可以选择接或不接.在每次预约服务之间要有休息时间,因此她不能接受相邻的预约.
给定一个预约请求序列,替按摩师找到最优的预约集合(总预约时间最长),返回总的分钟数
注意:本题相对原题稍作改动

示例1:输入:[1,2,3,1]
      输出:4
解释:选择1号预约和3号预约,总时长=1+3=4
示例2:输入:[2,7,9,3,1]
      输出:12
解释:选择1号预约,3号预约和5号预约,总时长=2+9+1=12
示例3:
输入:[2,1,4,5,3,1,1,3]
输出:12
解释:选择1号预约,3号预约5号预约和8号预约,总时长=2+4+3+3=12
*/

//当预约请求数为单数时,比较下标为奇数和偶数对应的总预约时长即可;预约请求为偶数且总预约时长相等时,比较元素大小再做改动

#include<stdio.h>
int main(void)
{
    int i,j,k,t,n,a[20];
    int sum,sum1,max;
    char ch;
    n=0;
    for(i=0;i<30;i++){
        ch=getchar();
        if(ch==']') break;
        scanf("%d",&a[i]);
        n=n+1;
    }
    sum=sum1=0;
    for(i=0;i<n;i++){
        sum=sum+a[i];                        /*所有预约请求总时长*/
        if(i%2==0){
            sum1=sum1+a[i];                  /*下标为偶数的预约请求时长*/
        }
    }
    //sum2=sum-sum1;
    if(n%2==0){
        if(sum1>sum/2) printf("%d\n",sum1);
        else printf("%d\n",sum-sum1);
        return 0;
    }
    k=0;
    for(i=0;i<n;i+=2){
        k=k+a[i];
        for(j=i+3;j<n;j+=2){
            t=k+sum-sum1
        }
    }
    printf("%d\n",max);
    return 0;
}
