//0-c 康托展开

//官方简介：康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。
//康托展开运算:X=a[n]*(n-1)!+a[n-1]*(n-2)!+...+a[i]*(i-1)!+...+a[2]*1!+a[1]*0!
//其中a[i]为整数,表示原数的第i位在当前未出现的元素中是排在第几个（即相当于该元素的逆序数），并且0<=a[i]<i,1<=i<=n
//通俗简介：康托展开可以求解一个排列的序号，比如：12345序号为1，12354序号为2，按字典序增加编号递增，依次类推。

//康托展开举例:在5个数的排列组合中，计算 34152的康托展开值
//首位是3，则小于3的数有两个，为1和2，a[5]=2，则首位小于3的所有排列组合为a[5]*(5-1)!
//第二位是4，由于第一位小于4，1、2、3中一定会有1个充当第一位，所以排在4之下的只剩2个，所以其实计算的是在第二位之后小于4的个数。因此a[4]=2
//第三位是1，则在其之后小于1的数有0个，所以a[3]=0
//第四位是5，则在其之后小于5的数有1个，为2，所以a[2]=1
//最后一位就不用计算啦，因为在它之后已经没有数了，所以a[1]固定为0
//根据公式：X=2*4!+2*3!+0*2!+1*1!+0*0!=61
//所以比34152小的组合有61个，即34152是排第62


#include<stdio.h>
double fact (int n);
int main(void)
{
    int N,s,i,j,k,X,x,sum,a[10000],b[10000];  /*x表示该数的位数，b[i]表示该元素逆序数(位于该元素后比之小的数的个数）*/
    printf("输入一个数：");
    scanf("%d",&N);
    x=0;
    X=0;
    sum=N;    /*保留输入数的初值*/  /*重要，易忽略*/
    for(i=1;i<=sum;i++){
            s=N%10;
            N=N/10;
            x=x+1;
            a[i]=s;
            if(N==0) break;   /*将数的各位上元素分离并存放于a[i]中，并得出数的位数*/
    }
    b[1]=0;    /*末尾数上必为零*/
    for(i=x;i>1;i--){
            b[i]=0;
        for(j=i-1;j>=1;j--){
            if(a[i]>a[j]) b[i]=b[i]+1;   /*求出逆序数并存放于b[i]中*/
        }
    }
    for(i=x;i>=1;i--){
        X=b[i]*fact(i-1)+X;  /*分步计算X*/
    }

    printf("\n比该数小的组合有%d个，即该数排第%d位！\n",X,X+1);
    return 0;
}

/*定义求n！的函数*/
double fact (int n)
{
    int i;
    double result;
    result=1;
    for(i=1;i<=n;i++)     /*执行循环n次，计算n！*/
        result=result*i;

    return result;
}
